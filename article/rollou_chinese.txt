# 枚举法
通过列举所有情况然后逐一判断，从而得到结果。从本质上看，就是把问题用一定的数据结构描述，然后用某种方式遍历它，以寻求问题的解。

# 动态规划算法
这个也是一个精确的算法。动态规划，简单说来就是知道一个状态，然后根据状态转移方程得到另外一个状态。根据这两个状态间的转换，递推获得最终解。
考虑这样一个问题，假如问题有n个阶段，每个阶段都有多个状态，不同阶段的状态数不必相同，一个阶段的一个状态可以得到下个阶段的所有状态中的几个。那我们要计算出最终阶段的状态数自然要经历之前每个阶段的某些状态。
如果下一步最优是从当前最优得到的，所以为了计算最终的最优值，只需要存储每一步的最优值即可，解决符合这种性质的问题的算法就变成了前文提到的贪婪算法。
如果一个阶段的最优无法用前一个阶段的最优得到呢？这时你需要保存的是之前每个阶段所经历的那个状态，根据这些信息才能计算出下一个状态！每个阶段的状态或许不多，但是每个状态都可以转移到下一阶段的多个状态，所以解的复杂度就是指数的，因此时间复杂度也是指数的。这种之前的选择会影响到下一步的选择的情况就叫做有后效性。
每个阶段的最优状态可以从之前某个阶段的某个或某些状态直接得到这个性质叫做最优子结构；

而不管之前这个状态是如何得到的这个性质叫做无后效性。
动态规划算法的设计可以分为如下四个步骤

1. 描述最优解的结构
2. 递归定义最优解的值
3. 按自底向上的方式计算最优解的值
4. 由计算出的结果构造最优解

# 贪婪算法
贪婪算法是一种短视算法，它会每次选择一个局部最优解，而不会考虑到该解对于今后的影响。一般来说，他的时间复杂度比较低，虽然贪婪算法并不从整体上最优加以考虑，导致它所作出的选择只是某种意义下的局部最优选择，这在工程实践中反而比较常用。
# rollout算法研究
rollout算法对各种动态和离散优化问题具有十分优异的表现。作为近似的动态规划算法，一个rollout算法，在每个决策阶段会通过以称为基策略的贪心策略模拟未来事件的方法来使得选择近似理想的方案。虽然在很多情况下rollout算法，可以保证执行情况和它们的基策略一样，已经出现了一些理论成果显示采用rollout算法，性能会有额外的改善。根据现有文献的随机模型，本文分析被称之为consecutive rollout和exhaustive rollout的两种rollout方法，这两者采用简单的贪婪算法作为基策略。我们分析这两种算法在普遍问题下的应用场景及算法流程，然后结合我们的实际问题，对这两种算法进行分析。
##consecutive rollout
 - 算法思路
 consecutive rollout算法的程序流程见下面，该算法输入为。。。，输出为。。。。，并调用贪婪算法作为其子程序。
 算法流程。。

  - 边界分析

##exhaustive rollout
 - 算法思路
在每次迭代中，用t索引，该算法考虑在现有的顺序一它计算由移动每个项目序列的前部，施加致盲贪婪算法得到的值的所有项目。然后，该算法具有最高估计值添加项（如果它存在）到溶液中。我们暗含的假设一致的打破平局方法，如该项目优先考虑以最低的指数。下一次迭代，然后用物品的其余序列前进。
考虑
 算法流程。

  - 边界分析



我们可以发现，对于 consecutive rollout 算法，他会依次对当前的是否选择情况进行一个基策略，看是选择还是不选择的结果会好一些，对于 exhaustive rollout 算法，它需要对每次剩余的结果进行穷举，然后把其中的某一项移动最前方，对该序列再次进行遍历，然后从其中选择一个最优的。
结合我们的实际情况，本文需要调度的是M个传感器的选择问题，每一步的选择情况都是固定的，是一个和M有关的表达式。可以很方便的使用 consecutive rollout 算法。而在传感器的选择方面，具有很强的时序相关性，时间序列无法随意改变，所以 exhaustive rollout 算法显然不适用于本文的情况。
另外本文采用的rollout算法，均为单次迭代算法，在今后的工作中我们可以考虑rollout算法的第二次迭代。一个相关的议题是仍考虑rollout算法只是第一次迭代，但具有较大的超前长度（如试图对所有项目进行了 exhaustive rollout，而不仅仅是单独的每个项）。

