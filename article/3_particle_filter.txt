# 粒子滤波算法研究
## 基本算法
粒子滤波器是贝叶斯滤波器的一种可替代的非参数实现。就像histogram滤波器，粒子滤波器通过有限数量的参数逼近后验概率。但是，它们产生这些参数的方式以及状态空间的转移是不同的。粒子滤波器的核心思想是由一组根据这个后验概率得到的状态的随机样本来表示后验概率bel(xt)。粒子滤波用一组从这个分布得到的采样来表示这个分布，而不是由参数形式表示分布（例如表示一个正态分布概率密度的指数函数）。这样的表示是近似的，但它是非参数，因此它可以表示更广阔的分布比空间。

在粒子滤波器中，一个后验分布的采样称为粒子，由下式表示

X_t := x_t^([1]),x_t^([2]),...,x_t^([M])
每个粒子x_t^([m])(1≤m≤M)是在时间t状态的的具体实例，也就是，对于在真实世界时间t状态可以是在什么的一个假设。 在这里M表示

书78PR 90pdf页数
表4.3 粒子滤波算法，基于重要性采样的贝叶斯滤波器的变体。

粒子数。在实践中，粒子的数量M通常是一个大数，例如，M = 1000。在一些实现中，M是一个t或者其他和belief bel(x_t)有关量的函数。
粒子滤波器的重点是根据粒子集合X_t近似belief state bel(x_t)。理想的情况下，状态假设包括在粒子集合中的可能性应该正比于它的贝叶斯滤波后验概率bel(x_t)：

x_t^([m])~p(x_t|z_(1:t),u_(1:t))

由上式可知，一个状态空间的一个子区域由采样填充的越密集，真实的状态就跟可能落入这个区域。正如我们将在下面讨论，对于标准粒子滤波算法该特性仅在M近似于∞时成立。对于有限M，粒子是从具有略微不同的分布中得到。在实践中，这种差异是可以忽略的，只要粒子的数量不能太小（例如，M≥100）。

粒子滤波算法递归构建belief bel(x_t)根据早一个时间步长的belief
bel(x_(t-1))。因为belief是由粒子集合表示，这意味着粒子滤波器构造的粒子从XT-1到XT递归。粒子滤波器算法的最基本的变体可以参考<(￣3￣)>
表！ 。该算法的输入是
粒子集合XT-1，最近的控制UT和最近的量测ZT。该算法首先构造一个临时粒子集合ˉx，它类似于（但不等同）的bel(x_t)。它如下系统地处理输入粒子集合X_(t-1)中的每个粒子X [M]
1. 第4行基于粒子×〔米]叔1和控制UT在时间t产生一个假想状态。。。。 t。所得采样由m作为索引，这表明它是由XT-1的第m个粒子产生的。该步骤包括从下一状态分布p（XT | UT，XT-1）的采样。对于任意分布P（XT | UT，XT-1），没有从状态转移概率采样的统一公式。然而，生产实践中的许多主要分布具有有效的采样算法。步骤4中这组由迭代M次产生的粒子是bel(x_t)的滤波器的表示。
2，第5行计算每个粒子X [M]的重要性因子，记作W [M]。重要性因子用于合并观测ZT进入粒子集合。因此，重要性因子是粒子×〔米得到观测ZT的的概率。即，瓦特[米]
T = P（ZT | X [M] T）。如果我们的把W [M] T考虑为一个粒子的权重，那么加权粒子集合表示（近似地）贝叶斯滤波器后验概率bel(x_t)。
3.第8行至11行。这些行实现了所谓的重采样或重要性重采样。该算法对于临时集合ˉXT中的M个粒子判断是否需要。保留每个粒子的概率是由它的重要性权重给出。重采样将一个具有M个粒子的集合转换为另一个具有相同的大小的粒子集。通过将重要性权重纳入重采样过程中，粒子的分布因此而变化：在重采样步骤之前，他们根据bel(x_t)分布，经过重采样后，它们近似根据后验概率bel(x_t) η= P（ZT | X [M]T）bel(x_t)。事实上，所得的样本集合通常具有许多重复的。更重要的是没有被包括在XT中的粒子：那些于具有较低重要性权重的粒子。

重采样步骤具有强制粒子返回后验概率bel(x_t)的重要作用。实际上，另一种（通常比较差）版本的粒子滤波器将永远不会重采样，而是将维持每个粒子的重要性权重，权重被初始化为1然后根据下式更新：
W [米]T = P（ZT | X [M] t）的W [M] T-1（4.24）

这样的粒子滤波算法仍接近后验概率，但它的许多粒子将在后验概率很低的区域结束。其结果是，它需要更多的粒子，需要的数量的多少取决于后验概率的大小。重采样步骤是优胜劣汰的达尔文想法的概率实现：重新调整它的粒子集合到高后验概率状态空间的区域。通过这样做，它把滤波器算法的计算资源分配到最重要的状态空间所在区域。
## 重要性采样
用于粒子滤波器的推导，应当证明是有用的，下面以更详细地步骤讨论重采样。图4.2显示了采样步骤下的intuition。图4.2A示出了一个被称为目标分布的概率分布的密度函数f。我们想实现的是从f计算采样。然而，从f直接采样可能是不可能的。相反，我们可以从相关密度生成粒子，在图4.2B标记g。对应于概率密度g的分布称为(proposal distribution)建议分布。概率密度g为必须满足函数f（x）> 0意味着g（x）的> 0，使得对于从任何f可能生成的状态，根据g进行采样时，都可以有一个非零的概率来生成一个粒子。然而，所得到的粒子集合，在图4.2B的底部示出，是根据g而不是f分布的。特别地，对于任何一个区间范围。。。。（或更一般地，任何Borel集合A）粒子的经验计数落入一个收敛于A下对g的积分：
（4.25）
为了消除f和g之间的不同，粒子x^([m])是由商加权

（4.26）
p81 tu%%%%%%%%%

这由图4.2C表示：该图中的竖线表示重要性权重的大小。重要性权重是每个粒子的非归一化概率质量。特别地，我们有
4.27）
其中第一项作为用于所有重要性权重的正规化因子。换言之，尽管我们由密度g生成粒子，适当加权的粒子收敛于密度F。
具体的趋近设计对于集合A的一个积分。显然，一个粒子集合表示一个离散分布，而在我们的例子中f是连续的。由于这个原因，就没有可能与粒子集合相关联的密度。 因此，收敛是f的累积分布函数，而不是密度本身。重要抽样的一个很好的特性是如果在f（x）> 0时都有g（x）> 0它趋近于真密度。在大多数情况下，收敛律为O(1/sqrt(M))，其中M是采样的数目。恒定系数取决于f(s)和g(s)的相似度。
在粒子滤波器中，密度f对应于目标belief bel(x_t)。在此假设下，X_(t-1)中的粒子根据bel(x_t-1)分布，密度g对应于乘积分布：
P（XT | UT，XT-1）bel(x_t-1)  （4.28）
这个分布称为建议分布。 
## 公式化
为了获得粒子滤波器的数学表示，我们可以把粒子当作状态序列的采样
(4.29）
相应地修改该算法也很容易：只需追加粒子。。。到状态采样序列。。。。这种粒子滤波器计算在所有的状态序列上的后验概率：
bel（X0：T）= P（X0：T | U1：T，Z1：T）（4.30）
而不是belief bel(x_t)= P（XT | U1：T，Z1：T）。诚然，在所有状态序列上的空间是巨大的，并且用粒子覆盖它通常是显然不可行。然而，这不应阻止我们在这里，因为这个定义只是推导粒子滤波算法的手段。
根据文献xxx我们有，如下公式
（4.31）

验证初始条件是不重要的的，假设根据先验概率P（X0）采样获得我们的第一个粒子集。让我们假定粒子集在时刻t-1，根据bel（X0：T-1）分布。对于这个集合中的第m个粒子X [米]
0：T-1，在我们的算法的步骤4中产生的样本x [M] T是从建议分布产生的：
ρ（XT | XT-1，UT）bel（X0：T-1）=ρ（XT | XT-1，UT）P（X0：叔1 | Z0：T-1，U0：T-1）4.32）
（4.33）
常量η没有任何作用，因为重采样发生概率与正比于重要性权重。通过重采样概率正比于重要性权重的粒子，所得的粒子根据proposal与重要性权重的乘积分布
（4.34）
（请注意，常数系数η这里不同于（4.33）中的因子。）在表4.2的算法转换为从一个简单地观测得到，如果x [米]0：t为根据bel（X0：吨）分布，则状态采样x [米]t根据bel(x_t)分布。
正如我们下面讨论的，由于我们考虑到规一化常数，这个推导仅对于M→∞正确。然而，即使是有限的M，它也是有效的。
## 误差来源